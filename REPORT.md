# Report

I began this task by creating a new React app using `create-react-app`, set up the Git repository, and restructured the `/src` folder. I then removed any unnecessary code for my solution.

Before I started, I considered two cases: one for no emails, and one for at least one email. For both cases, a method of selecting dates is required, so this is the first component on which I worked. The `DateSelector` component consists of a date selector button, a search button, and a text field that displays the selected date range. These items are displayed horizontally, so I used a flexbox. I put the PDF document into an image manipulation program to get the exact dimensions for margin and font size, so these should look more or less exactly the same. At this point, I added some dummy state - a start and end date - and two dummy functions that would - if implemented - allow the ability to open the calendar and filter the emails by date respectfully.
The rest of this case was simple to complete, with a caveat. I made the component `EmailCount`, which displays the number of emails in the date range, and added the logo, but I could only get it aligned horizontally. I came back to this later as it's a minor issue, but I did manage to fix it with another flexbox. Since `EmailCount` depends on the date range selected in the `DateSelector` component, I raised the DateSelector state to the component that contains it, `App`.

The second component I worked on was the email snippet (`EmailSnippet`); this is the short form of the email displayed in `EmailContainer`. Each email appears to have a sender, a number of recipients, a subject, a body, and a date. Some also have attachments.
Firstly, I created some dummy data in `App` to be passed down as props to each `EmailSnippet` through the `EmailContainer`. `EmailContainer` delegates each email object to an EmailSnippet component using the `map` method, with each key being the `email.id`.
I see in the PDF that, if there is only one recipient and it is too long for the column, it is truncated with an ellipsis. However, if there is more than one recipient, only a whole number of recipients are shown, and the following recipients are cut off with a badge to show how many aren't visible. I couldn't actually figure out a way to do this at the time, so I was forced to do what I thought would be similar: always displaying only one email address in full, and displaying the badge if there were any addresses not shown.

It's simple to implement a rule for `on:hover` such that the text in the row the mouse is hovering over turns blue and the background turns grey, but it's more difficult to implement this and have the paperclip SVG change colour too. I created a blue paperclip SVG (`icon_clip_hover`) and implemented some stateful logic that changed both the style of the text and the SVG on row hover. Because the icon doesn't just change colour - the icon is switched for a different one - I couldn't just use `on:hover`. React doesn't have a simple equivalent, so I used `onMouseEnter()` and `onMouseLeave()` to track the mouse's position.

The date format changes depending on how long ago the date was. If the email was sent today, only the time is displayed. If it was sent this year, the shortened month and day are displayed. If longer, the full yyyy/dd/mm date is shown. I wrote a function that compares any given date with the current date and time to determine the correct format.

To finish things off, I added the ability to sort the emails by clicking on the respective table heading. This involved adding some state that controls sorting direction (ascending, descending, or neither). At this point, the desktop version was pretty much complete.

I next made the app responsive. Although there were no new features to add to the mobile layout, the `EmailSnippet` component required restyling.
Because the React component is returning code that changes based on screen size, I couldn't use media queries as I would use for the rest of the responsive design, as media queries only affect CSS. Hence, I used a custom React hook. I had never used custom hooks before this, so I used one I found online, but it gets the job done.

For Mission 2, I had to think. I imagine, although I haven't implemented the feature, clicking an email once would open it to fill the entire page, like with other popular email services. But this mission asks that multiple email bodies should be able to be read at once. So I thought: how about double-clicking the `EmailSnippet` opens up the corresponding email body underneath? So I made the `EmailBody` component, which receives the email body and returns the correctly formatted result, depending on the size of the screen. It works the same on both desktop and mobile, in that a responsively-sized, scrollable box is displayed on double-clicking an `EmailSnippet`. Double-clicking the snippet a second time closes it, and multiple email bodies can be shown concurrently, fulfilling the mission criteria.